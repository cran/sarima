## Do not edit this file manually.
## It has been automatically generated from *.org sources.

sarima_KalmanLike <- function(y, mod, nit = 0L, update = FALSE)
{
    # x <- .Call(C_KalmanLike, y, mod, nit, FALSE, update)
    # z <- list(Lik = 0.5*(log(x[1L]) + x[2L]), s2 = x[1L])
    # if(update) attr(z, "mod") <- attr(x, "mod")
    x0 <- uniKalmanLikelihood0b(y, mod, nit, FALSE, update)
    x <- x0[[1]]
    x[1:2] <- x[1:2]/x[3]
    z <- list(Lik = 0.5*(log(x[1L]) + x[2L]), 
              css = 0.5*log(x[1L]),
              s2 = x[1L])
    if(update) 
        attr(z, "mod") <- attr(x0, "mod")
    z
}

sarima_KalmanRun <- function(y, mod, nit = 0L, update = FALSE)
{
    # z <- .Call(C_KalmanLike, y, mod, nit, TRUE, update)
    z <- uniKalmanLikelihood0b(y, mod, nit, TRUE, update)
    # x <- z$values
    x <- z[[1]]
    x[1:2] <- x[1:2]/x[3]
    
    # z[[1L]] <- c(Lik = 0.5*(log(x[1L]) + x[2L]), s2 = x[1L])
    # z
    ## 2018-08-23 return  additional quantities
    res <- list(values = c(Lik = 0.5*(log(x[1L]) + x[2L]), 
                           css = 0.5*log(x[1L]), 
                           s2 = x[1L]),
                resid = z[[2]],
                states = z[[3]],
                gain = z[[4]])
    if(update) 
        attr(res, "mod") <- attr(z, "mod")
    res
}

sarima_KalmanForecast <- function(n.ahead, mod, update = FALSE)
{
    # x0 <- .Call(C_KalmanFore, n.ahead, mod, update)
    x0 <- uniKalmanForecast0b(n.ahead, mod, update)
    z <- list(pred = x0[[1L]], 
              var  = x0[[2L]])
    if(update) 
        attr(z, "mod") <- attr(x0, "mod")
    z
}

sarima_KalmanForeUp <- function(y, n.ahead, mod, nit = 0L, update = FALSE)
{
    x0 <- uniKalmanForeUp0b(y, n.ahead, mod, nit, update)
    z <- list(pred = x0[[1L]], 
              var  = x0[[2L]])
    .matrixToList <- function(mat){
        out <- as.list(data.frame(mat))
        names(out) <- NULL
        out
    }
    z <- lapply(z, .matrixToList)
    if(update) 
        attr(z, "mod") <- attr(x0, "mod")
    z
}
